<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title id="title">NekoToken FEED Claim & Stake Tool</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        textarea { width: 100%; height: 200px; margin-bottom: 10px; }
        button { padding: 10px 20px; background-color: #4CAF50; color: white; border: none; cursor: pointer; margin-right: 10px; }
        button:hover { background-color: #45a049; }
        #status { margin-top: 10px; white-space: pre-wrap; }
        .settings { margin: 10px 0; }
        .settings label { display: block; margin-bottom: 5px; }
        .settings input { width: 200px; margin-bottom: 10px; }
    </style>
</head>
<body onload="updateLanguage()">
    <h1 id="title">NekoToken FEED Claim & Stake Tool</h1>
    <div class="settings">
        <label id="labelRpcUrl">Shibarium RPC URL: <input type="text" id="rpcUrl" value="https://www.shibrpc.com"></label>
        <label id="labelChainId">Chain ID: <input type="text" id="chainId" value="109" readonly></label>
        <label id="labelNetworkName">Network Name: <input type="text" id="networkName" value="Shibarium" readonly></label>
        <label id="labelCurrencySymbol">Currency Symbol: <input type="text" id="currencySymbol" value="BONE" readonly></label>
        <label id="labelBlockExplorer">Block Explorer: <input type="text" id="blockExplorer" value="https://www.shibariumscan.io" readonly></label>
        <label id="labelLanguage">Language: <select id="language" onchange="updateLanguage()">
            <option value="en">English</option>
            <option value="zh">中文</option>
        </select></label>
    </div>
    <p id="labelPrivateKeys">Enter one private key per line (with "0x" prefix):</p>
    <textarea id="privateKeys" placeholder="e.g.\n0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef\n0xabcdef1234567890abcdef1234567890abcdef1234567890abcdef1234567890"></textarea>
    <div class="settings">
        <label id="labelGasPrice">Gas Price (Gwei): <input type="number" id="gasPrice" value="3.2" step="0.1" min="0"></label>
        <label id="labelGasLimit">Gas Limit: <input type="number" id="gasLimit" value="600000" min="21000"></label>
        <label id="labelProcessInterval">Process Interval (seconds): <input type="number" id="processInterval" value="5" min="1"></label>
    </div>
    <button id="processButton" onclick="processWallets()">Claim NEKO & Stake NEKO</button>
    <button id="stakeFeedButton" onclick="stakeFeedWallets()">Batch Stake FEED</button>
    <button id="unstakeFeedButton" onclick="unstakeFeedWallets()">Batch Unstake FEED</button>
    <button id="checkBalanceButton" onclick="checkBalances()">Check Balances</button>
    <div id="status">Status: Ready</div>

    <script src="https://cdn.jsdelivr.net/npm/web3@1.7.4/dist/web3.min.js"></script>
    <script>
        const NEKO_CONTRACT_ADDRESS = "0x63A67329f761517570345eE86f791F74f9DC5461";
        const FEED_CONTRACT_ADDRESS = "0xe9Cb2D7ADC24Fc59FE00D6C0A0669BDF16805Fe0";
        const MIN_STAKE_UNIT = BigInt(10000 * 10**18);
        const FEED_STAKE_AMOUNT = BigInt(10000000000 * 10**18);
        const MAX_UINT256 = "115792089237316195423570985008687907853269984665640564039457584007913129639935"; // type(uint256).max

        const NEKO_CONTRACT_ABI = [{"inputs":[],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"owner","type":"address"},{"indexed":true,"internalType":"address","name":"spender","type":"address"},{"indexed":false,"internalType":"uint256","name":"value","type":"uint256"}],"name":"Approval","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"user","type":"address"},{"indexed":false,"internalType":"uint256","name":"amount","type":"uint256"}],"name":"FeedStaked","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"user","type":"address"},{"indexed":false,"internalType":"uint256","name":"amount","type":"uint256"}],"name":"FeedUnstaked","type":"event"},{"anonymous":false,"inputs":[],"name":"MiningEnded","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"user","type":"address"},{"indexed":false,"internalType":"uint256","name":"amount","type":"uint256"}],"name":"NekoStaked","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"user","type":"address"},{"indexed":false,"internalType":"uint256","name":"amount","type":"uint256"}],"name":"NekoUnstaked","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"previousOwner","type":"address"},{"indexed":true,"internalType":"address","name":"newOwner","type":"address"}],"name":"OwnershipTransferred","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"user","type":"address"},{"indexed":false,"internalType":"uint256","name":"amount","type":"uint256"},{"indexed":false,"internalType":"string","name":"rewardType","type":"string"}],"name":"RewardsClaimed","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"from","type":"address"},{"indexed":true,"internalType":"address","name":"to","type":"address"},{"indexed":false,"internalType":"uint256","name":"value","type":"uint256"}],"name":"Transfer","type":"event"},{"inputs":[{"internalType":"address","name":"owner","type":"address"},{"internalType":"address","name":"spender","type":"address"}],"name":"allowance","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"spender","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"approve","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"account","type":"address"}],"name":"balanceOf","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"claimFeedRewards","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"claimNekoRewards","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"decimals","outputs":[{"internalType":"uint8","name":"","type":"uint8"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"spender","type":"address"},{"internalType":"uint256","name":"subtractedValue","type":"uint256"}],"name":"decreaseAllowance","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"user","type":"address"}],"name":"getFeedPendingRewards","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"user","type":"address"}],"name":"getFeedStakeInfo","outputs":[{"internalType":"uint256","name":"amount","type":"uint256"},{"internalType":"uint256","name":"lastBlock","type":"uint256"},{"internalType":"uint256","name":"reward","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"user","type":"address"}],"name":"getNekoPendingRewards","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"user","type":"address"}],"name":"getNekoStakeInfo","outputs":[{"internalType":"uint256","name":"amount","type":"uint256"},{"internalType":"uint256","name":"lastBlock","type":"uint256"},{"internalType":"uint256","name":"reward","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"spender","type":"address"},{"internalType":"uint256","name":"addedValue","type":"uint256"}],"name":"increaseAllowance","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"name","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"stakeNeko","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"stakeFeed","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"symbol","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"totalSupply","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"transfer","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"from","type":"address"},{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"transferFrom","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"newOwner","type":"address"}],"name":"transferOwnership","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"unstakeFeed","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"unstakeNeko","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"","type":"address"}],"name":"feedUserInfo","outputs":[{"internalType":"uint256","name":"amount","type":"uint256"},{"internalType":"bool","name":"isStaked","type":"bool"},{"internalType":"uint256","name":"lastRewardBlock","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"","type":"address"}],"name":"nekoUserInfo","outputs":[{"internalType":"uint256","name":"principal","type":"uint256"},{"internalType":"uint256","name":"lastRewardBlock","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"totalFeedStaked","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"totalNekoStaked","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"}];
        const FEED_CONTRACT_ABI = [{"inputs":[{"internalType":"address","name":"spender","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"approve","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"account","type":"address"}],"name":"balanceOf","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"transfer","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"from","type":"address"},{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"transferFrom","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"}];

        const messages = {
            en: {
                title: "NekoToken FEED Claim & Stake Tool",
                labelRpcUrl: "Shibarium RPC URL: ",
                labelChainId: "Chain ID: ",
                labelNetworkName: "Network Name: ",
                labelCurrencySymbol: "Currency Symbol: ",
                labelBlockExplorer: "Block Explorer: ",
                labelLanguage: "Language: ",
                labelPrivateKeys: "Enter one private key per line (with \"0x\" prefix):",
                privateKeysPlaceholder: "e.g.\n0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef\n0xabcdef1234567890abcdef1234567890abcdef1234567890abcdef1234567890",
                labelGasPrice: "Gas Price (Gwei): ",
                labelGasLimit: "Gas Limit: ",
                labelProcessInterval: "Process Interval (seconds): ",
                processButton: "Claim NEKO & Stake NEKO",
                stakeFeedButton: "Batch Stake FEED",
                unstakeFeedButton: "Batch Unstake FEED",
                checkBalanceButton: "Check Balances",
                statusStarting: "Status: Starting...",
                statusReady: "Status: Ready",
                testingRPC: "Testing RPC connection...",
                connectedToChain: "Connected to chain ID: ",
                expectedChain: " (Shibarium should be 109)",
                chainMismatch: "Error: Not connected to Shibarium network (chain ID should be 109).",
                rpcError: "Error: Failed to connect to RPC: ",
                noPrivateKeys: "Error: No private keys provided.",
                invalidGasPrice: "Error: Invalid Gas Price.",
                invalidGasLimit: "Error: Invalid Gas Limit (minimum 21000).",
                invalidInterval: "Error: Invalid Process Interval (minimum 1 second).",
                processingWallet: "Processing wallet ",
                balance: "NEKO Balance: ",
                feedBalance: "FEED Balance: ",
                feedPending: "FEED Pending Rewards: ",
                nekoPending: "NEKO Pending Rewards: ",
                claimingFeed: "Claiming FEED rewards for ",
                stakingNeko: "Staking ",
                nekoFor: " NEKO for ",
                approvingFeed: "Approving FEED for ",
                stakingFeed: "Staking FEED for ",
                unstakingFeed: "Unstaking FEED for ",
                lowBalanceWarning: "Warning: Wallet ",
                hasLowBalance: " has low BONE balance (",
                mayNotCoverGas: "), may not cover Gas fees.",
                insufficientFeedBalance: "Insufficient FEED balance for staking: ",
                alreadyStaked: "FEED already staked for ",
                notStaked: "FEED not staked for ",
                claimSuccess: "Claim successful! Tx: ",
                approveSuccess: "Approve successful! Tx: ",
                stakeSuccess: "Stake successful! Tx: ",
                unstakeSuccess: "Unstake successful! Tx: ",
                noRewards: "No FEED rewards to claim for ",
                insufficientBalance: "Insufficient NEKO balance for staking: ",
                errorProcessing: "Error processing ",
                errorMessage: ": ",
                allProcessed: "All wallets processed. Done!",
                generalError: "Error: ",
                insufficientAllowance: "Insufficient FEED allowance: ",
                requiredAllowance: ", required: "
            },
            zh: {
                title: "NekoToken FEED 领取与质押工具",
                labelRpcUrl: "Shibarium RPC 地址: ",
                labelChainId: "链 ID: ",
                labelNetworkName: "网络名称: ",
                labelCurrencySymbol: "货币符号: ",
                labelBlockExplorer: "区块浏览器: ",
                labelLanguage: "语言: ",
                labelPrivateKeys: "每行输入一个私钥 (带 \"0x\" 前缀):",
                privateKeysPlaceholder: "例如:\n0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef\n0xabcdef1234567890abcdef1234567890abcdef1234567890abcdef1234567890",
                labelGasPrice: "Gas 价格 (Gwei): ",
                labelGasLimit: "Gas 限制: ",
                labelProcessInterval: "处理间隔 (秒): ",
                processButton: "领取 NEKO 并质押 NEKO",
                stakeFeedButton: "批量质押 FEED",
                unstakeFeedButton: "批量取消质押 FEED",
                checkBalanceButton: "检查余额",
                statusStarting: "状态: 正在启动...",
                statusReady: "状态: 准备就绪",
                testingRPC: "测试 RPC 连接...",
                connectedToChain: "已连接到链 ID: ",
                expectedChain: " (Shibarium 应为 109)",
                chainMismatch: "错误: 未连接到 Shibarium 网络 (链 ID 应为 109)。",
                rpcError: "错误: 无法连接到 RPC: ",
                noPrivateKeys: "错误: 未提供私钥。",
                invalidGasPrice: "错误: 无效的 Gas 价格。",
                invalidGasLimit: "错误: 无效的 Gas 限制 (最小 21000)。",
                invalidInterval: "错误: 无效的处理间隔 (最小 1 秒)。",
                processingWallet: "正在处理钱包 ",
                balance: "NEKO 余额: ",
                feedBalance: "FEED 余额: ",
                feedPending: "FEED 待领奖励: ",
                nekoPending: "NEKO 待领奖励: ",
                claimingFeed: "为以下地址领取 FEED 奖励 ",
                stakingNeko: "为以下地址质押 ",
                nekoFor: " NEKO ",
                approvingFeed: "为以下地址批准 FEED ",
                stakingFeed: "为以下地址质押 FEED ",
                unstakingFeed: "为以下地址取消质押 FEED ",
                lowBalanceWarning: "警告: 钱包 ",
                hasLowBalance: " 的 BONE 余额低 (",
                mayNotCoverGas: ")，可能无法支付 Gas 费用。",
                insufficientFeedBalance: "FEED 余额不足以质押: ",
                alreadyStaked: "FEED 已质押 ",
                notStaked: "FEED 未质押 ",
                claimSuccess: "领取成功! 交易: ",
                approveSuccess: "批准成功! 交易: ",
                stakeSuccess: "质押成功! 交易: ",
                unstakeSuccess: "取消质押成功! 交易: ",
                noRewards: "没有可领取的 FEED 奖励 ",
                insufficientBalance: "NEKO 余额不足以质押: ",
                errorProcessing: "处理时出错 ",
                errorMessage: ": ",
                allProcessed: "所有钱包处理完成。完成!",
                generalError: "错误: ",
                insufficientAllowance: "FEED 授权金额不足: ",
                requiredAllowance: "，需要: "
            }
        };

        function getMessage(key) {
            return messages[document.getElementById("language").value][key] || key;
        }

        function updateLanguage() {
            document.getElementById("title").textContent = getMessage("title");
            document.getElementById("labelRpcUrl").childNodes[0].textContent = getMessage("labelRpcUrl");
            document.getElementById("labelChainId").childNodes[0].textContent = getMessage("labelChainId");
            document.getElementById("labelNetworkName").childNodes[0].textContent = getMessage("labelNetworkName");
            document.getElementById("labelCurrencySymbol").childNodes[0].textContent = getMessage("labelCurrencySymbol");
            document.getElementById("labelBlockExplorer").childNodes[0].textContent = getMessage("labelBlockExplorer");
            document.getElementById("labelLanguage").childNodes[0].textContent = getMessage("labelLanguage");
            document.getElementById("labelPrivateKeys").textContent = getMessage("labelPrivateKeys");
            document.getElementById("privateKeys").placeholder = getMessage("privateKeysPlaceholder");
            document.getElementById("labelGasPrice").childNodes[0].textContent = getMessage("labelGasPrice");
            document.getElementById("labelGasLimit").childNodes[0].textContent = getMessage("labelGasLimit");
            document.getElementById("labelProcessInterval").childNodes[0].textContent = getMessage("labelProcessInterval");
            document.getElementById("processButton").textContent = getMessage("processButton");
            document.getElementById("stakeFeedButton").textContent = getMessage("stakeFeedButton");
            document.getElementById("unstakeFeedButton").textContent = getMessage("unstakeFeedButton");
            document.getElementById("checkBalanceButton").textContent = getMessage("checkBalanceButton");
            document.getElementById("status").textContent = getMessage("statusReady");
        }

        async function initializeWeb3() {
            const status = document.getElementById("status");
            const rpcUrl = document.getElementById("rpcUrl").value.trim();
            const expectedChainId = 109;

            if (!rpcUrl) {
                status.textContent += getMessage("rpcError") + "Please provide a valid Shibarium RPC URL.\n";
                return null;
            }

            const web3 = new Web3(new Web3.providers.HttpProvider(rpcUrl));
            try {
                status.textContent += getMessage("testingRPC") + "\n";
                const networkChainId = await web3.eth.getChainId();
                status.textContent += getMessage("connectedToChain") + networkChainId + getMessage("expectedChain") + "\n";
                if (networkChainId !== expectedChainId) {
                    status.textContent += getMessage("chainMismatch") + "\n";
                    return null;
                }
                return web3;
            } catch (error) {
                status.textContent += getMessage("rpcError") + error.message + "\n";
                return null;
            }
        }

        async function processWallets() {
            const status = document.getElementById("status");
            status.textContent = getMessage("statusStarting") + "\n";

            const web3 = await initializeWeb3();
            if (!web3) return;

            const nekoContract = new web3.eth.Contract(NEKO_CONTRACT_ABI, NEKO_CONTRACT_ADDRESS);
            const privateKeys = document.getElementById("privateKeys").value.trim().split("\n").filter(key => key.length > 0);
            if (privateKeys.length < 1) {
                status.textContent += getMessage("noPrivateKeys") + "\n";
                return;
            }

            const gasPriceGwei = parseFloat(document.getElementById("gasPrice").value);
            const gasLimit = parseInt(document.getElementById("gasLimit").value);
            const processInterval = parseInt(document.getElementById("processInterval").value) * 1000;

            if (isNaN(gasPriceGwei) || gasPriceGwei <= 0) {
                status.textContent += getMessage("invalidGasPrice") + "\n";
                return;
            }
            if (isNaN(gasLimit) || gasLimit < 21000) {
                status.textContent += getMessage("invalidGasLimit") + "\n";
                return;
            }
            if (isNaN(processInterval) || processInterval < 1000) {
                status.textContent += getMessage("invalidInterval") + "\n";
                return;
            }

            const gasPriceWei = web3.utils.toWei(gasPriceGwei.toString(), "gwei");

            try {
                for (const pk of privateKeys) {
                    const account = web3.eth.accounts.privateKeyToAccount(pk.trim());
                    web3.eth.accounts.wallet.add(account);
                    status.textContent += getMessage("processingWallet") + account.address + "\n";

                    const balance = await web3.eth.getBalance(account.address);
                    const balanceInBONE = web3.utils.fromWei(balance, "ether");
                    if (balanceInBONE < 0.01) {
                        status.textContent += getMessage("lowBalanceWarning") + account.address + getMessage("hasLowBalance") + balanceInBONE + getMessage("mayNotCoverGas") + "\n";
                    }

                    let nekoBalance = BigInt(await nekoContract.methods.balanceOf(account.address).call());
                    const feedRewards = BigInt(await nekoContract.methods.getFeedPendingRewards(account.address).call());

                    status.textContent += getMessage("balance") + web3.utils.fromWei(nekoBalance.toString(), "ether") + " NEKO\n";
                    status.textContent += getMessage("feedPending") + web3.utils.fromWei(feedRewards.toString(), "ether") + " NEKO\n";

                    if (feedRewards > 0n) {
                        status.textContent += getMessage("claimingFeed") + account.address + "...\n";
                        try {
                            const tx = await nekoContract.methods.claimFeedRewards().send({
                                from: account.address,
                                gas: gasLimit,
                                gasPrice: gasPriceWei
                            });
                            status.textContent += getMessage("claimSuccess") + tx.transactionHash + "\n";
                            nekoBalance += feedRewards;
                        } catch (error) {
                            status.textContent += getMessage("errorProcessing") + account.address + getMessage("errorMessage") + error.message + "\n";
                        }
                        await new Promise(resolve => setTimeout(resolve, processInterval));
                    } else {
                        status.textContent += getMessage("noRewards") + account.address + "\n";
                    }

                    if (nekoBalance >= MIN_STAKE_UNIT) {
                        const stakeAmount = (nekoBalance / MIN_STAKE_UNIT) * MIN_STAKE_UNIT;
                        status.textContent += getMessage("stakingNeko") + web3.utils.fromWei(stakeAmount.toString(), "ether") + getMessage("nekoFor") + account.address + "...\n";
                        try {
                            const tx = await nekoContract.methods.stakeNeko(stakeAmount.toString()).send({
                                from: account.address,
                                gas: gasLimit,
                                gasPrice: gasPriceWei
                            });
                            status.textContent += getMessage("stakeSuccess") + tx.transactionHash + "\n";
                        } catch (error) {
                            status.textContent += getMessage("errorProcessing") + account.address + getMessage("errorMessage") + error.message + "\n";
                        }
                        await new Promise(resolve => setTimeout(resolve, processInterval));
                    } else {
                        status.textContent += getMessage("insufficientBalance") + web3.utils.fromWei(nekoBalance.toString(), "ether") + " NEKO\n";
                    }
                }
                status.textContent += getMessage("allProcessed") + "\n";
            } catch (error) {
                status.textContent += getMessage("generalError") + error.message + "\n";
            }
        }

        async function stakeFeedWallets() {
            const status = document.getElementById("status");
            status.textContent = getMessage("statusStarting") + "\n";

            const web3 = await initializeWeb3();
            if (!web3) return;

            const nekoContract = new web3.eth.Contract(NEKO_CONTRACT_ABI, NEKO_CONTRACT_ADDRESS);
            const feedContract = new web3.eth.Contract(FEED_CONTRACT_ABI, FEED_CONTRACT_ADDRESS);
            const privateKeys = document.getElementById("privateKeys").value.trim().split("\n").filter(key => key.length > 0);
            if (privateKeys.length < 1) {
                status.textContent += getMessage("noPrivateKeys") + "\n";
                return;
            }

            const gasPriceGwei = parseFloat(document.getElementById("gasPrice").value);
            const gasLimit = parseInt(document.getElementById("gasLimit").value);
            const processInterval = parseInt(document.getElementById("processInterval").value) * 1000;

            if (isNaN(gasPriceGwei) || gasPriceGwei <= 0) {
                status.textContent += getMessage("invalidGasPrice") + "\n";
                return;
            }
            if (isNaN(gasLimit) || gasLimit < 21000) {
                status.textContent += getMessage("invalidGasLimit") + "\n";
                return;
            }
            if (isNaN(processInterval) || processInterval < 1000) {
                status.textContent += getMessage("invalidInterval") + "\n";
                return;
            }

            const gasPriceWei = web3.utils.toWei(gasPriceGwei.toString(), "gwei");

            try {
                for (const pk of privateKeys) {
                    const account = web3.eth.accounts.privateKeyToAccount(pk.trim());
                    web3.eth.accounts.wallet.add(account);
                    status.textContent += getMessage("processingWallet") + account.address + "\n";

                    const balance = await web3.eth.getBalance(account.address);
                    const balanceInBONE = web3.utils.fromWei(balance, "ether");
                    if (balanceInBONE < 0.01) {
                        status.textContent += getMessage("lowBalanceWarning") + account.address + getMessage("hasLowBalance") + balanceInBONE + getMessage("mayNotCoverGas") + "\n";
                    }

                    const feedBalance = BigInt(await feedContract.methods.balanceOf(account.address).call());
                    const feedUserInfo = await nekoContract.methods.feedUserInfo(account.address).call();

                    status.textContent += getMessage("feedBalance") + web3.utils.fromWei(feedBalance.toString(), "ether") + " FEED\n";

                    if (feedUserInfo.isStaked) {
                        status.textContent += getMessage("alreadyStaked") + account.address + "\n";
                        continue;
                    }

                    if (feedBalance < FEED_STAKE_AMOUNT) {
                        status.textContent += getMessage("insufficientFeedBalance") + web3.utils.fromWei(feedBalance.toString(), "ether") + " FEED\n";
                        continue;
                    }

                    status.textContent += getMessage("approvingFeed") + account.address + "...\n";
                    try {
                        const allowance = BigInt(await feedContract.methods.allowance(account.address, NEKO_CONTRACT_ADDRESS).call());
                        if (allowance < FEED_STAKE_AMOUNT) {
                            const approveTx = await feedContract.methods.approve(NEKO_CONTRACT_ADDRESS, MAX_UINT256).send({
                                from: account.address,
                                gas: gasLimit,
                                gasPrice: gasPriceWei
                            });
                            status.textContent += getMessage("approveSuccess") + approveTx.transactionHash + "\n";
                            await new Promise(resolve => setTimeout(resolve, 20000)); // 等待 20 秒确保授权生效
                        }
                    } catch (error) {
                        status.textContent += getMessage("errorProcessing") + account.address + getMessage("errorMessage") + error.message + "\n";
                        continue;
                    }

                    const updatedAllowance = BigInt(await feedContract.methods.allowance(account.address, NEKO_CONTRACT_ADDRESS).call());
                    if (updatedAllowance < FEED_STAKE_AMOUNT) {
                        status.textContent += getMessage("insufficientAllowance") + web3.utils.fromWei(updatedAllowance.toString(), "ether") + getMessage("requiredAllowance") + web3.utils.fromWei(FEED_STAKE_AMOUNT.toString(), "ether") + " FEED\n";
                        continue;
                    }

                    const updatedFeedBalance = BigInt(await feedContract.methods.balanceOf(account.address).call());
                    if (updatedFeedBalance < FEED_STAKE_AMOUNT) {
                        status.textContent += getMessage("insufficientFeedBalance") + web3.utils.fromWei(updatedFeedBalance.toString(), "ether") + " FEED\n";
                        continue;
                    }

                    const updatedFeedUserInfo = await nekoContract.methods.feedUserInfo(account.address).call();
                    if (updatedFeedUserInfo.isStaked) {
                        status.textContent += getMessage("alreadyStaked") + account.address + "\n";
                        continue;
                    }

                    status.textContent += getMessage("stakingFeed") + account.address + "...\n";
                    try {
                        await nekoContract.methods.stakeFeed().call({ from: account.address });
                        const stakeTx = await nekoContract.methods.stakeFeed().send({
                            from: account.address,
                            gas: gasLimit,
                            gasPrice: gasPriceWei
                        });
                        status.textContent += getMessage("stakeSuccess") + stakeTx.transactionHash + "\n";
                    } catch (error) {
                        status.textContent += getMessage("errorProcessing") + account.address + getMessage("errorMessage") + error.message + "\n";
                    }
                    await new Promise(resolve => setTimeout(resolve, processInterval));
                }
                status.textContent += getMessage("allProcessed") + "\n";
            } catch (error) {
                status.textContent += getMessage("generalError") + error.message + "\n";
            }
        }

        async function unstakeFeedWallets() {
            const status = document.getElementById("status");
            status.textContent = getMessage("statusStarting") + "\n";

            const web3 = await initializeWeb3();
            if (!web3) return;

            const nekoContract = new web3.eth.Contract(NEKO_CONTRACT_ABI, NEKO_CONTRACT_ADDRESS);
            const privateKeys = document.getElementById("privateKeys").value.trim().split("\n").filter(key => key.length > 0);
            if (privateKeys.length < 1) {
                status.textContent += getMessage("noPrivateKeys") + "\n";
                return;
            }

            const gasPriceGwei = parseFloat(document.getElementById("gasPrice").value);
            const gasLimit = parseInt(document.getElementById("gasLimit").value);
            const processInterval = parseInt(document.getElementById("processInterval").value) * 1000;

            if (isNaN(gasPriceGwei) || gasPriceGwei <= 0) {
                status.textContent += getMessage("invalidGasPrice") + "\n";
                return;
            }
            if (isNaN(gasLimit) || gasLimit < 21000) {
                status.textContent += getMessage("invalidGasLimit") + "\n";
                return;
            }
            if (isNaN(processInterval) || processInterval < 1000) {
                status.textContent += getMessage("invalidInterval") + "\n";
                return;
            }

            const gasPriceWei = web3.utils.toWei(gasPriceGwei.toString(), "gwei");

            try {
                for (const pk of privateKeys) {
                    const account = web3.eth.accounts.privateKeyToAccount(pk.trim());
                    web3.eth.accounts.wallet.add(account);
                    status.textContent += getMessage("processingWallet") + account.address + "\n";

                    const balance = await web3.eth.getBalance(account.address);
                    const balanceInBONE = web3.utils.fromWei(balance, "ether");
                    if (balanceInBONE < 0.01) {
                        status.textContent += getMessage("lowBalanceWarning") + account.address + getMessage("hasLowBalance") + balanceInBONE + getMessage("mayNotCoverGas") + "\n";
                    }

                    const feedUserInfo = await nekoContract.methods.feedUserInfo(account.address).call();

                    if (!feedUserInfo.isStaked) {
                        status.textContent += getMessage("notStaked") + account.address + "\n";
                        continue;
                    }

                    status.textContent += getMessage("unstakingFeed") + account.address + "...\n";
                    try {
                        const tx = await nekoContract.methods.unstakeFeed().send({
                            from: account.address,
                            gas: gasLimit,
                            gasPrice: gasPriceWei
                        });
                        status.textContent += getMessage("unstakeSuccess") + tx.transactionHash + "\n";
                    } catch (error) {
                        status.textContent += getMessage("errorProcessing") + account.address + getMessage("errorMessage") + error.message + "\n";
                    }
                    await new Promise(resolve => setTimeout(resolve, processInterval));
                }
                status.textContent += getMessage("allProcessed") + "\n";
            } catch (error) {
                status.textContent += getMessage("generalError") + error.message + "\n";
            }
        }

        async function checkBalances() {
            const status = document.getElementById("status");
            status.textContent = getMessage("statusStarting") + "\n";

            const web3 = await initializeWeb3();
            if (!web3) return;

            const nekoContract = new web3.eth.Contract(NEKO_CONTRACT_ABI, NEKO_CONTRACT_ADDRESS);
            const feedContract = new web3.eth.Contract(FEED_CONTRACT_ABI, FEED_CONTRACT_ADDRESS);
            const privateKeys = document.getElementById("privateKeys").value.trim().split("\n").filter(key => key.length > 0);
            if (privateKeys.length < 1) {
                status.textContent += getMessage("noPrivateKeys") + "\n";
                return;
            }

            try {
                for (const pk of privateKeys) {
                    const account = web3.eth.accounts.privateKeyToAccount(pk.trim());
                    const nekoBalance = await nekoContract.methods.balanceOf(account.address).call();
                    const feedBalance = await feedContract.methods.balanceOf(account.address).call();
                    const feedRewards = await nekoContract.methods.getFeedPendingRewards(account.address).call();
                    const nekoRewards = await nekoContract.methods.getNekoPendingRewards(account.address).call();

                    status.textContent += getMessage("processingWallet") + account.address + "\n";
                    status.textContent += getMessage("balance") + web3.utils.fromWei(nekoBalance, "ether") + " NEKO\n";
                    status.textContent += getMessage("feedBalance") + web3.utils.fromWei(feedBalance, "ether") + " FEED\n";
                    status.textContent += getMessage("feedPending") + web3.utils.fromWei(feedRewards, "ether") + " NEKO\n";
                    status.textContent += getMessage("nekoPending") + web3.utils.fromWei(nekoRewards, "ether") + " NEKO\n";
                }
                status.textContent += getMessage("allProcessed") + "\n";
            } catch (error) {
                status.textContent += getMessage("generalError") + error.message + "\n";
            }
        }
    </script>
</body>
</html>
